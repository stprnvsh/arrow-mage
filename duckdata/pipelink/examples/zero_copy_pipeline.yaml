name: Zero-Copy Pipeline Example
id: zero_copy_pipeline_001
description: A pipeline demonstrating true zero-copy data sharing across Python, R, and Julia
db_path: zero_copy_pipeline.duckdb
checkpointing:
  enabled: true
  frequency: node
nodes:
  - id: generate_data
    name: Generate Data
    description: Generate random test data in Python
    language: python
    script: |
      import pandas as pd
      import numpy as np
      from pipelink.crosslink.python.crosslink import CrossLink
      
      # Initialize CrossLink client
      crosslink = CrossLink("${DB_PATH}")
      
      # Generate random data
      np.random.seed(42)
      data = pd.DataFrame({
          'id': range(1000),
          'value': np.random.rand(1000),
          'category': np.random.choice(['A', 'B', 'C'], 1000)
      })
      
      # Push data to shared storage with metadata for zero-copy access
      dataset_id = crosslink.push_dataset(data, 'test_data', 
                                         description='Random test data for zero-copy pipeline')
      
      # Also register with NodeContext for pipeline integration
      context.save_dataset('test_data', data)
      
      print(f"Data registered with ID: {dataset_id}")
      print(f"Data shape: {data.shape}")
    outputs: [test_data]
  
  - id: transform_data_r
    name: Transform Data in R
    description: Apply transformations using R with zero-copy access
    language: r
    script: |
      library(dplyr)
      
      # Initialize CrossLink client
      source("/Users/pranavsateesh/arrow-mage/duckdata/pipelink/crosslink/r/CrossLink.R")
      crosslink <- CrossLinkClient$new("${DB_PATH}")
      
      # Get direct table reference to the data (zero-copy)
      table_ref <- crosslink$get_table_reference("test_data")
      
      # Use the reference to create a lazy query
      query_result <- crosslink$access_dataset("test_data", direct_access = TRUE)
      
      # Examine metadata - will show the table is accessed via reference
      print("Data access method:")
      print(table_ref$access_method)
      
      # Process data with dplyr - operations run against DuckDB directly
      # This doesn't fetch the data yet, maintaining zero-copy behavior
      transformed <- crosslink$run_query(paste0(
        "SELECT id, value, category, ",
        "value * value AS value_squared, ",
        "UPPER(category) AS category_upper ",
        "FROM ", table_ref$table_name
      ), return_data_frame = FALSE)
      
      # Register the transformed data (still zero-copy)
      new_id <- crosslink$register_external_table(
        crosslink$db_path,
        table_ref$table_name,
        name = "r_transformed_data",
        description = "Data transformed by R with zero-copy"
      )
      
      # For demonstration, also save to the node context
      # Get a small sample to verify (only fetches a few rows)
      sample_data <- crosslink$run_query(paste0(
        "SELECT * FROM ", table_ref$table_name, " LIMIT 5"
      ))
      
      # Save to node context
      context$save_dataset("r_transformed_data", sample_data)
      
      print(paste0("Transformed data registered with ID: ", new_id))
    inputs: [test_data]
    outputs: [r_transformed_data]
    depends_on: [generate_data]
  
  - id: analyze_data_julia
    name: Analyze Data in Julia
    description: Perform statistical analysis in Julia with zero-copy access
    language: julia
    script: |
      using Statistics
      using DataFrames
      
      # Import CrossLink module
      include("/Users/pranavsateesh/arrow-mage/duckdata/pipelink/crosslink/julia/crosslink.jl")
      
      # Initialize CrossLink client
      manager = CrossLink.CrossLinkManager("${DB_PATH}")
      
      # Get table reference (zero-copy)
      table_ref = CrossLink.get_table_reference(manager, "r_transformed_data")
      
      println("Zero-copy access method: ", table_ref["access_method"])
      
      # Run analytics directly using DuckDB (zero-copy)
      # This prepares a statement without fetching data
      query = """
        SELECT 
          category,
          COUNT(*) as count,
          AVG(value) as avg_value, 
          STDDEV(value) as std_value,
          MIN(value) as min_value,
          MAX(value) as max_value,
          AVG(value_squared) as avg_value_squared
        FROM $(table_ref["table_name"])
        GROUP BY category
      """
      
      # Execute the analytics query
      stats_by_category = CrossLink.run_query(manager, query)
      println("Statistics by category:")
      display(stats_by_category)
      
      # Save results to a new dataset
      dataset_id = CrossLink.push_data(manager, stats_by_category, "julia_analysis_results", 
                                      description="Statistical analysis from Julia")
      
      println("Analysis saved with ID: $dataset_id")
      
      # For demonstration, also save to node context
      PipeLink.NodeContext.save_dataset("julia_analysis_results", stats_by_category)
      
      # Clean up
      CrossLink.close(manager)
    inputs: [r_transformed_data]
    outputs: [julia_analysis_results]
    depends_on: [transform_data_r]
  
  - id: create_report
    name: Create Final Report
    description: Compile results in Python using zero-copy access
    language: python
    script: |
      import pandas as pd
      from pipelink.crosslink.python.crosslink import CrossLink
      
      # Initialize CrossLink client
      crosslink = CrossLink("${DB_PATH}")
      
      # Get references to all datasets
      original_ref = crosslink.get_table_reference("test_data")
      transformed_ref = crosslink.get_table_reference("r_transformed_data")
      analysis_ref = crosslink.get_table_reference("julia_analysis_results")
      
      print("Access method for original data:", original_ref["access_method"])
      print("Access method for transformed data:", transformed_ref["access_method"])
      print("Access method for analysis results:", analysis_ref["access_method"])
      
      # Run a query combining data from all sources without copying
      combined_query = f"""
      SELECT 
          'Original Data' as source,
          COUNT(*) as row_count,
          AVG(value) as avg_value
      FROM {original_ref["table_name"]}
      UNION ALL
      SELECT 
          'Transformed Data (R)' as source,
          COUNT(*) as row_count,
          AVG(value) as avg_value
      FROM {transformed_ref["table_name"]}
      """
      
      # Execute query and get results
      combined_stats = crosslink.query(combined_query)
      print("\nCombined statistics:")
      print(combined_stats)
      
      # Get analysis results
      analysis = crosslink.get_dataset("julia_analysis_results")
      print("\nJulia analysis results:")
      print(analysis)
      
      # Create a summary report
      report = {
          "pipeline_summary": "Zero-copy pipeline successfully executed",
          "data_sources": len([original_ref, transformed_ref, analysis_ref]),
          "total_records_processed": combined_stats["row_count"].sum(),
          "category_stats": analysis.to_dict(orient="records")
      }
      
      # Save report
      crosslink.push_dataset(pd.DataFrame([report]), "final_report", 
                            description="Final report of zero-copy pipeline")
      
      # Also save to context
      context.save_dataset("final_report", pd.DataFrame([report]))
      
      print("\nPipeline completed successfully with true zero-copy data sharing")
    inputs: [test_data, r_transformed_data, julia_analysis_results]
    outputs: [final_report]
    depends_on: [analyze_data_julia] 